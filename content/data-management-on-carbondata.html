<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='images/favicon.ico' rel='shortcut icon' type='image/x-icon'>
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CarbonData</title>
    <style>

    </style>
    <!-- Bootstrap -->

    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link href="css/style.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.scom/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>


</head>
<body>
<header>
    <nav class="navbar navbar-default navbar-custom cd-navbar-wrapper">
        <div class="container">
            <div class="navbar-header">
                <button aria-controls="navbar" aria-expanded="false" data-target="#navbar" data-toggle="collapse"
                        class="navbar-toggle collapsed" type="button">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="index.html" class="logo">
                    <img src="images/CarbonDataLogo.png" alt="CarbonData logo" title="CarbocnData logo"/>
                </a>
            </div>
            <div class="navbar-collapse collapse cd_navcontnt" id="navbar">
                <ul class="nav navbar-nav navbar-right navlist-custom">
                    <li><a href="index.html" class="hidden-xs"><i class="fa fa-home" aria-hidden="true"></i> </a>
                    </li>
                    <li><a href="index.html" class="hidden-lg hidden-md hidden-sm">Home</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle " data-toggle="dropdown" role="button" aria-haspopup="true"
                           aria-expanded="false"> Download <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="https://dist.apache.org/repos/dist/release/carbondata/1.4.1/"
                                   target="_blank">Apache CarbonData 1.4.1</a></li>
							<li>
                                <a href="https://dist.apache.org/repos/dist/release/carbondata/1.4.0/"
                                   target="_blank">Apache CarbonData 1.4.0</a></li>
                            <li>
                                <a href="https://dist.apache.org/repos/dist/release/carbondata/1.3.1/"
                                   target="_blank">Apache CarbonData 1.3.1</a></li>
                            <li>
                                <a href="https://dist.apache.org/repos/dist/release/carbondata/1.3.0/"
                                   target="_blank">Apache CarbonData 1.3.0</a></li>
                            <li>
                                <a href="https://cwiki.apache.org/confluence/display/CARBONDATA/Releases"
                                   target="_blank">Release Archive</a></li>
                        </ul>
                    </li>
                    <li><a href="mainpage.html" class="active">Documentation</a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                           aria-expanded="false">Community <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li>
                                <a href="https://github.com/apache/carbondata/blob/master/docs/How-to-contribute-to-Apache-CarbonData.md"
                                   target="_blank">Contributing to CarbonData</a></li>
                            <li>
                                <a href="https://github.com/apache/carbondata/blob/master/docs/release-guide.md"
                                   target="_blank">Release Guide</a></li>
                            <li>
                                <a href="https://cwiki.apache.org/confluence/display/CARBONDATA/PMC+and+Committers+member+list"
                                   target="_blank">Project PMC and Committers</a></li>
                            <li>
                                <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=66850609"
                                   target="_blank">CarbonData Meetups</a></li>
                            <li><a href="security.html">Apache CarbonData Security</a></li>
                            <li><a href="https://issues.apache.org/jira/browse/CARBONDATA" target="_blank">Apache
                                Jira</a></li>
                            <li><a href="videogallery.html">CarbonData Videos </a></li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="http://www.apache.org/" class="apache_link hidden-xs dropdown-toggle"
                           data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Apache</a>
                        <ul class="dropdown-menu">
                            <li><a href="http://www.apache.org/" target="_blank">Apache Homepage</a></li>
                            <li><a href="http://www.apache.org/licenses/" target="_blank">License</a></li>
                            <li><a href="http://www.apache.org/foundation/sponsorship.html"
                                   target="_blank">Sponsorship</a></li>
                            <li><a href="http://www.apache.org/foundation/thanks.html" target="_blank">Thanks</a></li>
                        </ul>
                    </li>

                    <li class="dropdown">
                        <a href="http://www.apache.org/" class="hidden-lg hidden-md hidden-sm dropdown-toggle"
                           data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Apache</a>
                        <ul class="dropdown-menu">
                            <li><a href="http://www.apache.org/" target="_blank">Apache Homepage</a></li>
                            <li><a href="http://www.apache.org/licenses/" target="_blank">License</a></li>
                            <li><a href="http://www.apache.org/foundation/sponsorship.html"
                                   target="_blank">Sponsorship</a></li>
                            <li><a href="http://www.apache.org/foundation/thanks.html" target="_blank">Thanks</a></li>
                        </ul>
                    </li>

                    <li>
                        <a href="#" id="search-icon"><i class="fa fa-search" aria-hidden="true"></i></a>

                    </li>

                </ul>
            </div><!--/.nav-collapse -->
            <div id="search-box">
                <form method="get" action="http://www.google.com/search" target="_blank">
                    <div class="search-block">
                        <table border="0" cellpadding="0" width="100%">
                            <tr>
                                <td style="width:80%">
                                    <input type="text" name="q" size=" 5" maxlength="255" value=""
                                           class="search-input"  placeholder="Search...."    required/>
                                </td>
                                <td style="width:20%">
                                    <input type="submit" value="Search"/></td>
                            </tr>
                            <tr>
                                <td align="left" style="font-size:75%" colspan="2">
                                    <input type="checkbox" name="sitesearch" value="carbondata.apache.org" checked/>
                                    <span style=" position: relative; top: -3px;"> Only search for CarbonData</span>
                                </td>
                            </tr>
                        </table>
                    </div>
                </form>
            </div>
        </div>
    </nav>
</header> <!-- end Header part -->

<div class="fixed-padding"></div> <!--  top padding with fixde header  -->

<section><!-- Dashboard nav -->
    <div class="container-fluid q">
        <div class="col-sm-12  col-md-12 maindashboard">
            <div class="row">
                <section>
                    <div style="padding:10px 15px;">
                        <div id="viewpage" name="viewpage">
                            <div class="row">
                                <div class="col-sm-12  col-md-12">
                                    <div>
<h1>
<a id="data-management-on-carbondata" class="anchor" href="#data-management-on-carbondata" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data Management on CarbonData</h1>
<p>This tutorial is going to introduce all commands and data operations on CarbonData.</p>
<ul>
<li><a href="#create-table">CREATE TABLE</a></li>
<li><a href="#create-database">CREATE DATABASE</a></li>
<li><a href="#table-management">TABLE MANAGEMENT</a></li>
<li><a href="#load-data">LOAD DATA</a></li>
<li><a href="#update-and-delete">UPDATE AND DELETE</a></li>
<li><a href="#compaction">COMPACTION</a></li>
<li><a href="#partition">PARTITION</a></li>
<li><a href="#bucketing">BUCKETING</a></li>
<li><a href="#segment-management">SEGMENT MANAGEMENT</a></li>
</ul>
<h2>
<a id="create-table" class="anchor" href="#create-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CREATE TABLE</h2>
<p>This command can be used to create a CarbonData table by specifying the list of fields along with the table properties. You can also specify the location where the table needs to be stored.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name[(col_name data_type , ...)]
STORED AS carbondata
[TBLPROPERTIES (property_name=property_value, ...)]
[LOCATION 'path']
</code></pre>
<p><strong>NOTE:</strong> CarbonData also supports "STORED AS carbondata" and "USING carbondata". Find example code at <a href="https://github.com/apache/carbondata/blob/master/examples/spark2/src/main/scala/org/apache/carbondata/examples/CarbonSessionExample.scala" target=_blank>CarbonSessionExample</a> in the CarbonData repo.</p>
<h3>
<a id="usage-guidelines" class="anchor" href="#usage-guidelines" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage Guidelines</h3>
<p>Following are the guidelines for TBLPROPERTIES, CarbonData's additional table options can be set via carbon.properties.</p>
<ul>
<li>
<p><strong>Dictionary Encoding Configuration</strong></p>
<p>Dictionary encoding is turned off for all columns by default from 1.3 onwards, you can use this command for including or excluding columns to do dictionary encoding.
Suggested use cases : do dictionary encoding for low cardinality columns, it might help to improve data compression ratio and performance.</p>
<pre><code>TBLPROPERTIES ('DICTIONARY_INCLUDE'='column1, column2')
</code></pre>
<p>NOTE: Dictionary Include/Exclude for complex child columns is not supported.</p>
</li>
<li>
<p><strong>Inverted Index Configuration</strong></p>
<p>By default inverted index is enabled, it might help to improve compression ratio and query speed, especially for low cardinality columns which are in reward position.
Suggested use cases : For high cardinality columns, you can disable the inverted index for improving the data loading performance.</p>
<pre><code>TBLPROPERTIES ('NO_INVERTED_INDEX'='column1, column3')
</code></pre>
</li>
<li>
<p><strong>Sort Columns Configuration</strong></p>
<p>This property is for users to specify which columns belong to the MDK(Multi-Dimensions-Key) index.</p>
<ul>
<li>If users don't specify "SORT_COLUMN" property, by default MDK index be built by using all dimension columns except complex data type column.</li>
<li>If this property is specified but with empty argument, then the table will be loaded without sort.</li>
<li>This supports only string, date, timestamp, short, int, long, and boolean data types.
Suggested use cases : Only build MDK index for required columns,it might help to improve the data loading performance.</li>
</ul>
<pre><code>TBLPROPERTIES ('SORT_COLUMNS'='column1, column3')
OR
TBLPROPERTIES ('SORT_COLUMNS'='')
</code></pre>
<p>NOTE: Sort_Columns for Complex datatype columns is not supported.</p>
</li>
<li>
<p><strong>Sort Scope Configuration</strong></p>
<p>This property is for users to specify the scope of the sort during data load, following are the types of sort scope.</p>
<ul>
<li>LOCAL_SORT: It is the default sort scope.</li>
<li>NO_SORT: It will load the data in unsorted manner, it will significantly increase load performance.</li>
<li>BATCH_SORT: It increases the load performance but decreases the query performance if identified blocks &gt; parallelism.</li>
<li>GLOBAL_SORT: It increases the query performance, especially high concurrent point query.
And if you care about loading resources isolation strictly, because the system uses the spark GroupBy to sort data, the resource can be controlled by spark.</li>
</ul>
</li>
</ul>
<pre><code>### Example:
</code></pre>
<pre><code> CREATE TABLE IF NOT EXISTS productSchema.productSalesTable (
                                productNumber INT,
                                productName STRING,
                                storeCity STRING,
                                storeProvince STRING,
                                productCategory STRING,
                                productBatch STRING,
                                saleQuantity INT,
                                revenue INT)
 STORED BY 'carbondata'
 TBLPROPERTIES ('SORT_COLUMNS'='productName,storeCity',
                'SORT_SCOPE'='NO_SORT')
</code></pre>
<p><strong>NOTE:</strong> CarbonData also supports "using carbondata". Find example code at <a href="https://github.com/apache/carbondata/blob/master/examples/spark2/src/main/scala/org/apache/carbondata/examples/SparkSessionExample.scala" target=_blank>SparkSessionExample</a> in the CarbonData repo.</p>
<ul>
<li>
<p><strong>Table Block Size Configuration</strong></p>
<p>This command is for setting block size of this table, the default value is 1024 MB and supports a range of 1 MB to 2048 MB.</p>
<pre><code>TBLPROPERTIES ('TABLE_BLOCKSIZE'='512')
</code></pre>
<p><strong>NOTE:</strong> 512 or 512M both are accepted.</p>
</li>
<li>
<p><strong>Table Compaction Configuration</strong></p>
<p>These properties are table level compaction configurations, if not specified, system level configurations in carbon.properties will be used.
Following are 5 configurations:</p>
<ul>
<li>MAJOR_COMPACTION_SIZE: same meaning as carbon.major.compaction.size, size in MB.</li>
<li>AUTO_LOAD_MERGE: same meaning as carbon.enable.auto.load.merge.</li>
<li>COMPACTION_LEVEL_THRESHOLD: same meaning as carbon.compaction.level.threshold.</li>
<li>COMPACTION_PRESERVE_SEGMENTS: same meaning as carbon.numberof.preserve.segments.</li>
<li>ALLOWED_COMPACTION_DAYS: same meaning as carbon.allowed.compaction.days.</li>
</ul>
<pre><code>TBLPROPERTIES ('MAJOR_COMPACTION_SIZE'='2048',
               'AUTO_LOAD_MERGE'='true',
               'COMPACTION_LEVEL_THRESHOLD'='5,6',
               'COMPACTION_PRESERVE_SEGMENTS'='10',
               'ALLOWED_COMPACTION_DAYS'='5')
</code></pre>
</li>
<li>
<p><strong>Streaming</strong></p>
<p>CarbonData supports streaming ingestion for real-time data. You can create the ?streaming? table using the following table properties.</p>
<pre><code>TBLPROPERTIES ('streaming'='true')
</code></pre>
</li>
<li>
<p><strong>Local Dictionary Configuration</strong></p>
</li>
</ul>
<p>Columns for which dictionary is not generated needs more storage space and in turn more IO. Also since more data will have to be read during query, query performance also would suffer.Generating dictionary per blocklet for such columns would help in saving storage space and assist in improving query performance as carbondata is optimized for handling dictionary encoded columns more effectively.Generating dictionary internally per blocklet is termed as local dictionary. Please refer to <a href="../file-structure-of-carbondata.html">File structure of Carbondata</a> for understanding about the file structure of carbondata and meaning of terms like blocklet.</p>
<p>Local Dictionary helps in:</p>
<ol>
<li>Getting more compression.</li>
<li>Filter queries and full scan queries will be faster as filter will be done on encoded data.</li>
<li>Reducing the store size and memory footprint as only unique values will be stored as part of local dictionary and corresponding data will be stored as encoded data.</li>
<li>Getting higher IO throughput.</li>
</ol>
<p><strong>NOTE:</strong></p>
<ul>
<li>
<p>Following Data Types are Supported for Local Dictionary:</p>
<ul>
<li>STRING</li>
<li>VARCHAR</li>
<li>CHAR</li>
</ul>
</li>
<li>
<p>Following Data Types are not Supported for Local Dictionary:</p>
<ul>
<li>SMALLINT</li>
<li>INTEGER</li>
<li>BIGINT</li>
<li>DOUBLE</li>
<li>DECIMAL</li>
<li>TIMESTAMP</li>
<li>DATE</li>
<li>BOOLEAN</li>
</ul>
</li>
<li>
<p>In case of multi-level complex dataType columns, primitive string/varchar/char columns are considered for local dictionary generation.</p>
</li>
</ul>
<p>Local dictionary will have to be enabled explicitly during create table or by enabling the system property 'carbon.local.dictionary.enable'. By default, Local Dictionary will be disabled for the carbondata table.</p>
<p>Local Dictionary can be configured using the following properties during create table command:</p>
<table>
<thead>
<tr>
<th>Properties</th>
<th>Default value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOCAL_DICTIONARY_ENABLE</td>
<td>false</td>
<td>Whether to enable local dictionary generation. <strong>NOTE:</strong> If this property is defined, it will override the value configured at system level by 'carbon.local.dictionary.enable'</td>
</tr>
<tr>
<td>LOCAL_DICTIONARY_THRESHOLD</td>
<td>10000</td>
<td>The maximum cardinality of a column upto which carbondata can try to generate local dictionary (maximum - 100000)</td>
</tr>
<tr>
<td>LOCAL_DICTIONARY_INCLUDE</td>
<td>string/varchar/char columns</td>
<td>Columns for which Local Dictionary has to be generated.<strong>NOTE:</strong> Those string/varchar/char columns which are added into DICTIONARY_INCLUDE option will not be considered for local dictionary generation.</td>
</tr>
<tr>
<td>LOCAL_DICTIONARY_EXCLUDE</td>
<td>none</td>
<td>Columns for which Local Dictionary need not be generated.</td>
</tr>
</tbody>
</table>
<p><strong>Fallback behavior:</strong></p>
<ul>
<li>When the cardinality of a column exceeds the threshold, it triggers a fallback and the generated dictionary will be reverted and data loading will be continued without dictionary encoding.</li>
</ul>
<p><strong>NOTE:</strong> When fallback is triggered, the data loading performance will decrease as encoded data will be discarded and the actual data is written to the temporary sort files.</p>
<p><strong>Points to be noted:</strong></p>
<ol>
<li>
<p>Reduce Block size:</p>
<p>Number of Blocks generated is less in case of Local Dictionary as compression ratio is high. This may reduce the number of tasks launched during query, resulting in degradation of query performance if the pruned blocks are less compared to the number of parallel tasks which can be run. So it is recommended to configure smaller block size which in turn generates more number of blocks.</p>
</li>
<li>
<p>All the page-level data for a blocklet needs to be maintained in memory until all the pages encoded for local dictionary is processed in order to handle fallback. Hence the memory required for local dictionary based table is more and this memory increase is proportional to number of columns.</p>
</li>
</ol>
<h3>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example:</h3>
<pre><code>CREATE TABLE carbontable(
          
            column1 string,
          
            column2 string,
          
            column3 LONG )
          
  STORED BY 'carbondata'
  TBLPROPERTIES('LOCAL_DICTIONARY_ENABLE'='true','LOCAL_DICTIONARY_THRESHOLD'='1000',
  'LOCAL_DICTIONARY_INCLUDE'='column1','LOCAL_DICTIONARY_EXCLUDE'='column2')
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>We recommend to use Local Dictionary when cardinality is high but is distributed across multiple loads</li>
<li>On a large cluster, decoding data can become a bottleneck for global dictionary as there will be many remote reads. In this scenario, it is better to use Local Dictionary.</li>
<li>When cardinality is less, but loads are repetitive, it is better to use global dictionary as local dictionary generates multiple dictionary files at blocklet level increasing redundancy.</li>
</ul>
<ul>
<li>
<p><strong>Caching Min/Max Value for Required Columns</strong>
By default, CarbonData caches min and max values of all the columns in schema.  As the load increases, the memory required to hold the min and max values increases considerably. This feature enables you to configure min and max values only for the required columns, resulting in optimized memory usage.</p>
<p>Following are the valid values for COLUMN_META_CACHE:</p>
<ul>
<li>If you want no column min/max values to be cached in the driver.</li>
</ul>
<pre><code>COLUMN_META_CACHE=??
</code></pre>
<ul>
<li>If you want only col1 min/max values to be cached in the driver.</li>
</ul>
<pre><code>COLUMN_META_CACHE=?col1?
</code></pre>
<ul>
<li>If you want min/max values to be cached in driver for all the specified columns.</li>
</ul>
<pre><code>COLUMN_META_CACHE=?col1,col2,col3,??
</code></pre>
<p>Columns to be cached can be specified either while creating table or after creation of the table.
During create table operation; specify the columns to be cached in table properties.</p>
<p>Syntax:</p>
<pre><code>CREATE TABLE [dbName].tableName (col1 String, col2 String, col3 int,?) STORED BY ?carbondata? TBLPROPERTIES (?COLUMN_META_CACHE?=?col1,col2,??)
</code></pre>
<p>Example:</p>
<pre><code>CREATE TABLE employee (name String, city String, id int) STORED BY ?carbondata? TBLPROPERTIES (?COLUMN_META_CACHE?=?name?)
</code></pre>
<p>After creation of table or on already created tables use the alter table command to configure the columns to be cached.</p>
<p>Syntax:</p>
<pre><code>ALTER TABLE [dbName].tableName SET TBLPROPERTIES (?COLUMN_META_CACHE?=?col1,col2,??)
</code></pre>
<p>Example:</p>
<pre><code>ALTER TABLE employee SET TBLPROPERTIES (?COLUMN_META_CACHE?=?city?)
</code></pre>
</li>
<li>
<p><strong>Caching at Block or Blocklet Level</strong></p>
<p>This feature allows you to maintain the cache at Block level, resulting in optimized usage of the memory. The memory consumption is high if the Blocklet level caching is maintained as a Block can have multiple Blocklet.</p>
<p>Following are the valid values for CACHE_LEVEL:</p>
<p><em>Configuration for caching in driver at Block level (default value).</em></p>
<pre><code>CACHE_LEVEL= ?BLOCK?
</code></pre>
<p><em>Configuration for caching in driver at Blocklet level.</em></p>
<pre><code>CACHE_LEVEL= ?BLOCKLET?
</code></pre>
<p>Cache level can be specified either while creating table or after creation of the table.
During create table operation specify the cache level in table properties.</p>
<p>Syntax:</p>
<pre><code>CREATE TABLE [dbName].tableName (col1 String, col2 String, col3 int,?) STORED BY ?carbondata? TBLPROPERTIES (?CACHE_LEVEL?=?Blocklet?)
</code></pre>
<p>Example:</p>
<pre><code>CREATE TABLE employee (name String, city String, id int) STORED BY ?carbondata? TBLPROPERTIES (?CACHE_LEVEL?=?Blocklet?)
</code></pre>
<p>After creation of table or on already created tables use the alter table command to configure the cache level.</p>
<p>Syntax:</p>
<pre><code>ALTER TABLE [dbName].tableName SET TBLPROPERTIES (?CACHE_LEVEL?=?Blocklet?)
</code></pre>
<p>Example:</p>
<pre><code>ALTER TABLE employee SET TBLPROPERTIES (?CACHE_LEVEL?=?Blocklet?)
</code></pre>
</li>
</ul>
<pre><code>- **Support Flat folder same as Hive/Parquet**

  This feature allows all carbondata and index files to keep directy under tablepath. Currently all carbondata/carbonindex files written under tablepath/Fact/Part0/Segment_NUM folder and it is not same as hive/parquet folder structure. This feature makes all files written will be directly under tablepath, it does not maintain any segment folder structure.This is useful for interoperability between the execution engines and plugin with other execution engines like hive or presto becomes easier.

  Following table property enables this feature and default value is false.
  ```
   'flat_folder'='true'
  ```
  Example:
  ```
  CREATE TABLE employee (name String, city String, id int) STORED BY ?carbondata? TBLPROPERTIES ('flat_folder'='true')
  ```

- **String longer than 32000 characters**

 In common scenarios, the length of string is less than 32000,
 so carbondata stores the length of content using Short to reduce memory and space consumption.
 To support string longer than 32000 characters, carbondata introduces a table property called `LONG_STRING_COLUMNS`.
 For these columns, carbondata internally stores the length of content using Integer.

 You can specify the columns as 'long string column' using below tblProperties:

 ```
 // specify col1, col2 as long string columns
 TBLPROPERTIES ('LONG_STRING_COLUMNS'='col1,col2')
 ```

 Besides, you can also use this property through DataFrame by
 ```
 df.format("carbondata")
   .option("tableName", "carbonTable")
   .option("long_string_columns", "col1, col2")
   .save()
 ```

 If you are using Carbon-SDK, you can specify the datatype of long string column as `varchar`.
 You can refer to SDKwriterTestCase for example.

 **NOTE:** The LONG_STRING_COLUMNS can only be string/char/varchar columns and cannot be dictionary_include/sort_columns/complex columns.
</code></pre>
<h2>
<a id="create-table-as-select" class="anchor" href="#create-table-as-select" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CREATE TABLE AS SELECT</h2>
<p>This function allows user to create a Carbon table from any of the Parquet/Hive/Carbon table. This is beneficial when the user wants to create Carbon table from any other Parquet/Hive table and use the Carbon query engine to query and achieve better query results for cases where Carbon is faster than other file formats. Also this feature can be used for backing up the data.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name 
STORED BY 'carbondata' 
[TBLPROPERTIES (key1=val1, key2=val2, ...)] 
AS select_statement;
</code></pre>
<h3>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h3>
<pre><code>carbon.sql("CREATE TABLE source_table(
                           id INT,
                           name STRING,
                           city STRING,
                           age INT)
            STORED AS parquet")
carbon.sql("INSERT INTO source_table SELECT 1,'bob','shenzhen',27")
carbon.sql("INSERT INTO source_table SELECT 2,'david','shenzhen',31")

carbon.sql("CREATE TABLE target_table
            STORED BY 'carbondata'
            AS SELECT city,avg(age) FROM source_table GROUP BY city")
            
carbon.sql("SELECT * FROM target_table").show
  // results:
  //    +--------+--------+
  //    |    city|avg(age)|
  //    +--------+--------+
  //    |shenzhen|    29.0|
  //    +--------+--------+

</code></pre>
<h2>
<a id="create-external-table" class="anchor" href="#create-external-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CREATE EXTERNAL TABLE</h2>
<p>This function allows user to create external table by specifying location.</p>
<pre><code>CREATE EXTERNAL TABLE [IF NOT EXISTS] [db_name.]table_name 
STORED BY 'carbondata' LOCATION ?$FilesPath?
</code></pre>
<h3>
<a id="create-external-table-on-managed-table-data-location" class="anchor" href="#create-external-table-on-managed-table-data-location" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create external table on managed table data location.</h3>
<p>Managed table data location provided will have both FACT and Metadata folder.
This data can be generated by creating a normal carbon table and use this path as $FilesPath in the above syntax.</p>
<p><strong>Example:</strong></p>
<pre><code>sql("CREATE TABLE origin(key INT, value STRING) STORED BY 'carbondata'")
sql("INSERT INTO origin select 100,'spark'")
sql("INSERT INTO origin select 200,'hive'")
// creates a table in $storeLocation/origin

sql(s"""
|CREATE EXTERNAL TABLE source
|STORED BY 'carbondata'
|LOCATION '$storeLocation/origin'
""".stripMargin)
checkAnswer(sql("SELECT count(*) from source"), sql("SELECT count(*) from origin"))
</code></pre>
<h3>
<a id="create-external-table-on-non-transactional-table-data-location" class="anchor" href="#create-external-table-on-non-transactional-table-data-location" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create external table on Non-Transactional table data location.</h3>
<p>Non-Transactional table data location will have only carbondata and carbonindex files, there will not be a metadata folder (table status and schema).
Our SDK module currently support writing data in this format.</p>
<p><strong>Example:</strong></p>
<pre><code>sql(
s"""CREATE EXTERNAL TABLE sdkOutputTable STORED BY 'carbondata' LOCATION
|'$writerPath' """.stripMargin)
</code></pre>
<p>Here writer path will have carbondata and index files.
This can be SDK output. Refer <a href="https://github.com/apache/carbondata/blob/master/docs/sdk-writer-guide.html" target=_blank>SDK Writer Guide</a>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Dropping of the external table should not delete the files present in the location.</li>
<li>When external table is created on non-transactional table data,
external table will be registered with the schema of carbondata files.
If multiple files with different schema is present, exception will be thrown.
So, If table registered with one schema and files are of different schema,
suggest to drop the external table and create again to register table with new schema.</li>
</ol>
<h2>
<a id="create-database" class="anchor" href="#create-database" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CREATE DATABASE</h2>
<p>This function creates a new database. By default the database is created in Carbon store location, but you can also specify custom location.</p>
<pre><code>CREATE DATABASE [IF NOT EXISTS] database_name [LOCATION path];
</code></pre>
<h3>
<a id="example-1" class="anchor" href="#example-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h3>
<pre><code>CREATE DATABASE carbon LOCATION ?hdfs://name_cluster/dir1/carbonstore?;
</code></pre>
<h2>
<a id="table-management" class="anchor" href="#table-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TABLE MANAGEMENT</h2>
<h3>
<a id="show-table" class="anchor" href="#show-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SHOW TABLE</h3>
<p>This command can be used to list all the tables in current database or all the tables of a specific database.</p>
<pre><code>SHOW TABLES [IN db_Name]
</code></pre>
<p>Example:</p>
<pre><code>SHOW TABLES
OR
SHOW TABLES IN defaultdb
</code></pre>
<h3>
<a id="alter-table" class="anchor" href="#alter-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ALTER TABLE</h3>
<p>The following section introduce the commands to modify the physical or logical state of the existing table(s).</p>
<ul>
<li>
<p><strong>RENAME TABLE</strong></p>
<p>This command is used to rename the existing table.</p>
<pre><code>ALTER TABLE [db_name.]table_name RENAME TO new_table_name
</code></pre>
<p>Examples:</p>
<pre><code>ALTER TABLE carbon RENAME TO carbonTable
OR
ALTER TABLE test_db.carbon RENAME TO test_db.carbonTable
</code></pre>
</li>
<li>
<p><strong>ADD COLUMNS</strong></p>
<p>This command is used to add a new column to the existing table.</p>
<pre><code>ALTER TABLE [db_name.]table_name ADD COLUMNS (col_name data_type,...)
TBLPROPERTIES('DICTIONARY_INCLUDE'='col_name,...',
'DEFAULT.VALUE.COLUMN_NAME'='default_value')
</code></pre>
<p>Examples:</p>
<pre><code>ALTER TABLE carbon ADD COLUMNS (a1 INT, b1 STRING)
</code></pre>
<pre><code>ALTER TABLE carbon ADD COLUMNS (a1 INT, b1 STRING) TBLPROPERTIES('DICTIONARY_INCLUDE'='a1')
</code></pre>
<pre><code>ALTER TABLE carbon ADD COLUMNS (a1 INT, b1 STRING) TBLPROPERTIES('DEFAULT.VALUE.a1'='10')
</code></pre>
<p>NOTE: Add Complex datatype columns is not supported.</p>
</li>
</ul>
<p>Users can specify which columns to include and exclude for local dictionary generation after adding new columns. These will be appended with the already existing local dictionary include and exclude columns of main table respectively.</p>
<pre><code>   ALTER TABLE carbon ADD COLUMNS (a1 STRING, b1 STRING) TBLPROPERTIES('LOCAL_DICTIONARY_INCLUDE'='a1','LOCAL_DICTIONARY_EXCLUDE'='b1')
</code></pre>
<ul>
<li>
<p><strong>DROP COLUMNS</strong></p>
<p>This command is used to delete the existing column(s) in a table.</p>
<pre><code>ALTER TABLE [db_name.]table_name DROP COLUMNS (col_name, ...)
</code></pre>
<p>Examples:</p>
<pre><code>ALTER TABLE carbon DROP COLUMNS (b1)
OR
ALTER TABLE test_db.carbon DROP COLUMNS (b1)

ALTER TABLE carbon DROP COLUMNS (c1,d1)
</code></pre>
<p>NOTE: Drop Complex child column is not supported.</p>
</li>
<li>
<p><strong>CHANGE DATA TYPE</strong></p>
<p>This command is used to change the data type from INT to BIGINT or decimal precision from lower to higher.
Change of decimal data type from lower precision to higher precision will only be supported for cases where there is no data loss.</p>
<pre><code>ALTER TABLE [db_name.]table_name CHANGE col_name col_name changed_column_type
</code></pre>
<p>Valid Scenarios</p>
<ul>
<li>Invalid scenario - Change of decimal precision from (10,2) to (10,5) is invalid as in this case only scale is increased but total number of digits remains the same.</li>
<li>Valid scenario - Change of decimal precision from (10,2) to (12,3) is valid as the total number of digits are increased by 2 but scale is increased only by 1 which will not lead to any data loss.</li>
<li>
<strong>NOTE:</strong> The allowed range is 38,38 (precision, scale) and is a valid upper case scenario which is not resulting in data loss.</li>
</ul>
<p>Example1:Changing data type of column a1 from INT to BIGINT.</p>
<pre><code>ALTER TABLE test_db.carbon CHANGE a1 a1 BIGINT
</code></pre>
<p>Example2:Changing decimal precision of column a1 from 10 to 18.</p>
<pre><code>ALTER TABLE test_db.carbon CHANGE a1 a1 DECIMAL(18,2)
</code></pre>
</li>
<li>
<p><strong>MERGE INDEX</strong></p>
<p>This command is used to merge all the CarbonData index files (.carbonindex) inside a segment to a single CarbonData index merge file (.carbonindexmerge). This enhances the first query performance.</p>
<pre><code> ALTER TABLE [db_name.]table_name COMPACT 'SEGMENT_INDEX'
 ```
 
 Examples:
 ```
 ALTER TABLE test_db.carbon COMPACT 'SEGMENT_INDEX'
 ```
 **NOTE:**
 * Merge index is not supported on streaming table.
 
</code></pre>
</li>
<li>
<p><strong>SET and UNSET for Local Dictionary Properties</strong></p>
<p>When set command is used, all the newly set properties will override the corresponding old properties if exists.</p>
<p>Example to SET Local Dictionary Properties:</p>
<pre><code>ALTER TABLE tablename SET TBLPROPERTIES('LOCAL_DICTIONARY_ENABLE'='false','LOCAL_DICTIONARY_THRESHOLD'='1000','LOCAL_DICTIONARY_INCLUDE'='column1','LOCAL_DICTIONARY_EXCLUDE'='column2')
</code></pre>
<p>When Local Dictionary properties are unset, corresponding default values will be used for these properties.</p>
<p>Example to UNSET Local Dictionary Properties:</p>
<pre><code>ALTER TABLE tablename UNSET TBLPROPERTIES('LOCAL_DICTIONARY_ENABLE','LOCAL_DICTIONARY_THRESHOLD','LOCAL_DICTIONARY_INCLUDE','LOCAL_DICTIONARY_EXCLUDE')
</code></pre>
<p><strong>NOTE:</strong> For old tables, by default, local dictionary is disabled. If user wants local dictionary for these tables, user can enable/disable local dictionary for new data at their discretion.
This can be achieved by using the alter table set command.</p>
</li>
</ul>
<h3>
<a id="drop-table" class="anchor" href="#drop-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DROP TABLE</h3>
<p>This command is used to delete an existing table.</p>
<pre><code>DROP TABLE [IF EXISTS] [db_name.]table_name
</code></pre>
<p>Example:</p>
<pre><code>DROP TABLE IF EXISTS productSchema.productSalesTable
</code></pre>
<h3>
<a id="refresh-table" class="anchor" href="#refresh-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REFRESH TABLE</h3>
<p>This command is used to register Carbon table to HIVE meta store catalogue from existing Carbon table data.</p>
<pre><code>REFRESH TABLE $db_NAME.$table_NAME
</code></pre>
<p>Example:</p>
<pre><code>REFRESH TABLE dbcarbon.productSalesTable
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>The new database name and the old database name should be same.</li>
<li>Before executing this command the old table schema and data should be copied into the new database location.</li>
<li>If the table is aggregate table, then all the aggregate tables should be copied to the new database location.</li>
<li>For old store, the time zone of the source and destination cluster should be same.</li>
<li>If old cluster used HIVE meta store to store schema, refresh will not work as schema file does not exist in file system.</li>
</ul>
<h3>
<a id="table-and-column-comment" class="anchor" href="#table-and-column-comment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table and Column Comment</h3>
<p>You can provide more information on table by using table comment. Similarly you can provide more information about a particular column using column comment.
You can see the column comment of an existing table using describe formatted command.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name[(col_name data_type [COMMENT col_comment], ...)]
  [COMMENT table_comment]
STORED BY 'carbondata'
[TBLPROPERTIES (property_name=property_value, ...)]
</code></pre>
<p>Example:</p>
<pre><code>CREATE TABLE IF NOT EXISTS productSchema.productSalesTable (
                              productNumber Int COMMENT 'unique serial number for product')
COMMENT ?This is table comment?
 STORED BY 'carbondata'
 TBLPROPERTIES ('DICTIONARY_INCLUDE'='productNumber')
</code></pre>
<p>You can also SET and UNSET table comment using ALTER command.</p>
<p>Example to SET table comment:</p>
<pre><code>ALTER TABLE carbon SET TBLPROPERTIES ('comment'='this table comment is modified');
</code></pre>
<p>Example to UNSET table comment:</p>
<pre><code>ALTER TABLE carbon UNSET TBLPROPERTIES ('comment');
</code></pre>
<h2>
<a id="load-data" class="anchor" href="#load-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LOAD DATA</h2>
<h3>
<a id="load-files-to-carbondata-table" class="anchor" href="#load-files-to-carbondata-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LOAD FILES TO CARBONDATA TABLE</h3>
<p>This command is used to load csv files to carbondata, OPTIONS are not mandatory for data loading process.
Inside OPTIONS user can provide any options like DELIMITER, QUOTECHAR, FILEHEADER, ESCAPECHAR, MULTILINE as per requirement.</p>
<pre><code>LOAD DATA [LOCAL] INPATH 'folder_path' 
INTO TABLE [db_name.]table_name 
OPTIONS(property_name=property_value, ...)
</code></pre>
<p>You can use the following options to load data:</p>
<ul>
<li>
<p><strong>DELIMITER:</strong> Delimiters can be provided in the load command.</p>
<pre><code>OPTIONS('DELIMITER'=',')
</code></pre>
</li>
<li>
<p><strong>QUOTECHAR:</strong> Quote Characters can be provided in the load command.</p>
<pre><code>OPTIONS('QUOTECHAR'='"')
</code></pre>
</li>
<li>
<p><strong>COMMENTCHAR:</strong> Comment Characters can be provided in the load command if user want to comment lines.</p>
<pre><code>OPTIONS('COMMENTCHAR'='#')
</code></pre>
</li>
<li>
<p><strong>HEADER:</strong> When you load the CSV file without the file header and the file header is the same with the table schema, then add 'HEADER'='false' to load data SQL as user need not provide the file header. By default the value is 'true'.
false: CSV file is without file header.
true: CSV file is with file header.</p>
<pre><code>OPTIONS('HEADER'='false') 
</code></pre>
<p><strong>NOTE:</strong> If the HEADER option exist and is set to 'true', then the FILEHEADER option is not required.</p>
</li>
<li>
<p><strong>FILEHEADER:</strong> Headers can be provided in the LOAD DATA command if headers are missing in the source files.</p>
<pre><code>OPTIONS('FILEHEADER'='column1,column2') 
</code></pre>
</li>
<li>
<p><strong>MULTILINE:</strong> CSV with new line character in quotes.</p>
<pre><code>OPTIONS('MULTILINE'='true') 
</code></pre>
</li>
<li>
<p><strong>ESCAPECHAR:</strong> Escape char can be provided if user want strict validation of escape character in CSV files.</p>
<pre><code>OPTIONS('ESCAPECHAR'='\') 
</code></pre>
</li>
<li>
<p><strong>SKIP_EMPTY_LINE:</strong> This option will ignore the empty line in the CSV file during the data load.</p>
<pre><code>OPTIONS('SKIP_EMPTY_LINE'='TRUE/FALSE') 
</code></pre>
</li>
<li>
<p><strong>COMPLEX_DELIMITER_LEVEL_1:</strong> Split the complex type data column in a row (eg., a$b$c --&gt; Array = {a,b,c}).</p>
<pre><code>OPTIONS('COMPLEX_DELIMITER_LEVEL_1'='$') 
</code></pre>
</li>
<li>
<p><strong>COMPLEX_DELIMITER_LEVEL_2:</strong> Split the complex type nested data column in a row. Applies level_1 delimiter &amp; applies level_2 based on complex data type (eg., a:b$c:d --&gt; Array&gt; = {{a,b},{c,d}}).</p>
<pre><code>OPTIONS('COMPLEX_DELIMITER_LEVEL_2'=':')
</code></pre>
</li>
<li>
<p><strong>ALL_DICTIONARY_PATH:</strong> All dictionary files path.</p>
<pre><code>OPTIONS('ALL_DICTIONARY_PATH'='/opt/alldictionary/data.dictionary')
</code></pre>
</li>
<li>
<p><strong>COLUMNDICT:</strong> Dictionary file path for specified column.</p>
<pre><code>OPTIONS('COLUMNDICT'='column1:dictionaryFilePath1,column2:dictionaryFilePath2')
</code></pre>
<p><strong>NOTE:</strong> ALL_DICTIONARY_PATH and COLUMNDICT can't be used together.</p>
</li>
<li>
<p><strong>DATEFORMAT/TIMESTAMPFORMAT:</strong> Date and Timestamp format for specified column.</p>
<pre><code>OPTIONS('DATEFORMAT' = 'yyyy-MM-dd','TIMESTAMPFORMAT'='yyyy-MM-dd HH:mm:ss')
</code></pre>
<p><strong>NOTE:</strong> Date formats are specified by date pattern strings. The date pattern letters in CarbonData are same as in JAVA. Refer to <a href="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html" target=_blank rel="nofollow">SimpleDateFormat</a>.</p>
</li>
<li>
<p><strong>SORT COLUMN BOUNDS:</strong> Range bounds for sort columns.</p>
<p>Suppose the table is created with 'SORT_COLUMNS'='name,id' and the range for name is aaa<del>zzz, the value range for id is 0</del>1000. Then during data loading, we can specify the following option to enhance data loading performance.</p>
<pre><code>OPTIONS('SORT_COLUMN_BOUNDS'='f,250;l,500;r,750')
</code></pre>
<p>Each bound is separated by ';' and each field value in bound is separated by ','. In the example above, we provide 3 bounds to distribute records to 4 partitions. The values 'f','l','r' can evenly distribute the records. Inside carbondata, for a record we compare the value of sort columns with that of the bounds and decide which partition the record will be forwarded to.</p>
<p><strong>NOTE:</strong></p>
<ul>
<li>SORT_COLUMN_BOUNDS will be used only when the SORT_SCOPE is 'local_sort'.</li>
<li>Carbondata will use these bounds as ranges to process data concurrently during the final sort percedure. The records will be sorted and written out inside each partition. Since the partition is sorted, all records will be sorted.</li>
<li>Since the actual order and literal order of the dictionary column are not necessarily the same, we do not recommend you to use this feature if the first sort column is 'dictionary_include'.</li>
<li>The option works better if your CPU usage during loading is low. If your system is already CPU tense, better not to use this option. Besides, it depends on the user to specify the bounds. If user does not know the exactly bounds to make the data distributed evenly among the bounds, loading performance will still be better than before or at least the same as before.</li>
<li>Users can find more information about this option in the description of PR1953.</li>
</ul>
</li>
<li>
<p><strong>SINGLE_PASS:</strong> Single Pass Loading enables single job to finish data loading with dictionary generation on the fly. It enhances performance in the scenarios where the subsequent data loading after initial load involves fewer incremental updates on the dictionary.</p>
</li>
</ul>
<p>This option specifies whether to use single pass for loading data or not. By default this option is set to FALSE.</p>
<pre><code> OPTIONS('SINGLE_PASS'='TRUE')
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>If this option is set to TRUE then data loading will take less time.</li>
<li>If this option is set to some invalid value other than TRUE or FALSE then it uses the default value.</li>
</ul>
<p>Example:</p>
<pre><code>LOAD DATA local inpath '/opt/rawdata/data.csv' INTO table carbontable
options('DELIMITER'=',', 'QUOTECHAR'='"','COMMENTCHAR'='#',
'HEADER'='false',
'FILEHEADER'='empno,empname,designation,doj,workgroupcategory,
workgroupcategoryname,deptno,deptname,projectcode,
projectjoindate,projectenddate,attendance,utilization,salary',
'MULTILINE'='true','ESCAPECHAR'='\','COMPLEX_DELIMITER_LEVEL_1'='$',
'COMPLEX_DELIMITER_LEVEL_2'=':',
'ALL_DICTIONARY_PATH'='/opt/alldictionary/data.dictionary',
'SINGLE_PASS'='TRUE')
</code></pre>
<ul>
<li>
<p><strong>BAD RECORDS HANDLING:</strong> Methods of handling bad records are as follows:</p>
<ul>
<li>Load all of the data before dealing with the errors.</li>
<li>Clean or delete bad records before loading data or stop the loading when bad records are found.</li>
</ul>
<pre><code>OPTIONS('BAD_RECORDS_LOGGER_ENABLE'='true', 'BAD_RECORD_PATH'='hdfs://hacluster/tmp/carbon', 'BAD_RECORDS_ACTION'='REDIRECT', 'IS_EMPTY_DATA_BAD_RECORD'='false')
</code></pre>
</li>
</ul>
<p><strong>NOTE:</strong></p>
<ul>
<li>BAD_RECORDS_ACTION property can have four type of actions for bad records FORCE, REDIRECT, IGNORE and FAIL.</li>
<li>FAIL option is its Default value. If the FAIL option is used, then data loading fails if any bad records are found.</li>
<li>If the REDIRECT option is used, CarbonData will add all bad records in to a separate CSV file. However, this file must not be used for subsequent data loading because the content may not exactly match the source record. You are advised to cleanse the original source record for further data ingestion. This option is used to remind you which records are bad records.</li>
<li>If the FORCE option is used, then it auto-converts the data by storing the bad records as NULL before Loading data.</li>
<li>If the IGNORE option is used, then bad records are neither loaded nor written to the separate CSV file.</li>
<li>In loaded data, if all records are bad records, the BAD_RECORDS_ACTION is invalid and the load operation fails.</li>
<li>The default maximum number of characters per column is 32000. If there are more than 32000 characters in a column, please refer to <em>String longer than 32000 characters</em> section.</li>
<li>Since Bad Records Path can be specified in create, load and carbon properties.
Therefore, value specified in load will have the highest priority, and value specified in carbon properties will have the least priority.</li>
</ul>
<p><strong>Bad Records Path:</strong></p>
<p>This property is used to specify the location where bad records would be written.</p>
<pre><code>TBLPROPERTIES('BAD_RECORDS_PATH'='/opt/badrecords'')
</code></pre>
<p>Example:</p>
<pre><code>LOAD DATA INPATH 'filepath.csv' INTO TABLE tablename
OPTIONS('BAD_RECORDS_LOGGER_ENABLE'='true','BAD_RECORD_PATH'='hdfs://hacluster/tmp/carbon',
'BAD_RECORDS_ACTION'='REDIRECT','IS_EMPTY_DATA_BAD_RECORD'='false')
</code></pre>
<ul>
<li>
<strong>GLOBAL_SORT_PARTITIONS:</strong> If the SORT_SCOPE is defined as GLOBAL_SORT, then user can specify the number of partitions to use while shuffling data for sort using GLOBAL_SORT_PARTITIONS. If it is not configured, or configured less than 1, then it uses the number of map task as reduce task. It is recommended that each reduce task deal with 512MB-1GB data.</li>
</ul>
<pre><code>OPTIONS('GLOBAL_SORT_PARTITIONS'='2')
</code></pre>
<p>NOTE:</p>
<ul>
<li>GLOBAL_SORT_PARTITIONS should be Integer type, the range is [1,Integer.MaxValue].</li>
<li>It is only used when the SORT_SCOPE is GLOBAL_SORT.</li>
</ul>
<h3>
<a id="insert-data-into-carbondata-table" class="anchor" href="#insert-data-into-carbondata-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>INSERT DATA INTO CARBONDATA TABLE</h3>
<p>This command inserts data into a CarbonData table, it is defined as a combination of two queries Insert and Select query respectively.
It inserts records from a source table into a target CarbonData table, the source table can be a Hive table, Parquet table or a CarbonData table itself.
It comes with the functionality to aggregate the records of a table by performing Select query on source table and load its corresponding resultant records into a CarbonData table.</p>
<pre><code>INSERT INTO TABLE &lt;CARBONDATA TABLE&gt; SELECT * FROM sourceTableName 
[ WHERE { &lt;filter_condition&gt; } ]
</code></pre>
<p>You can also omit the <code>table</code> keyword and write your query as:</p>
<pre><code>INSERT INTO &lt;CARBONDATA TABLE&gt; SELECT * FROM sourceTableName 
[ WHERE { &lt;filter_condition&gt; } ]
</code></pre>
<p>Overwrite insert data:</p>
<pre><code>INSERT OVERWRITE TABLE &lt;CARBONDATA TABLE&gt; SELECT * FROM sourceTableName 
[ WHERE { &lt;filter_condition&gt; } ]
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>The source table and the CarbonData table must have the same table schema.</li>
<li>The data type of source and destination table columns should be same</li>
<li>INSERT INTO command does not support partial success if bad records are found, it will fail.</li>
<li>Data cannot be loaded or updated in source table while insert from source table to target table is in progress.</li>
</ul>
<p>Examples</p>
<pre><code>INSERT INTO table1 SELECT item1, sum(item2 + 1000) as result FROM table2 group by item1
</code></pre>
<pre><code>INSERT INTO table1 SELECT item1, item2, item3 FROM table2 where item2='xyz'
</code></pre>
<pre><code>INSERT OVERWRITE TABLE table1 SELECT * FROM TABLE2
</code></pre>
<h2>
<a id="update-and-delete" class="anchor" href="#update-and-delete" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>UPDATE AND DELETE</h2>
<h3>
<a id="update" class="anchor" href="#update" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>UPDATE</h3>
<p>This command will allow to update the CarbonData table based on the column expression and optional filter conditions.</p>
<pre><code>UPDATE &lt;table_name&gt; 
SET (column_name1, column_name2, ... column_name n) = (column1_expression , column2_expression, ... column n_expression )
[ WHERE { &lt;filter_condition&gt; } ]
</code></pre>
<p>alternatively the following command can also be used for updating the CarbonData Table :</p>
<pre><code>UPDATE &lt;table_name&gt;
SET (column_name1, column_name2) =(select sourceColumn1, sourceColumn2 from sourceTable [ WHERE { &lt;filter_condition&gt; } ] )
[ WHERE { &lt;filter_condition&gt; } ]
</code></pre>
<p><strong>NOTE:</strong> The update command fails if multiple input rows in source table are matched with single row in destination table.</p>
<p>Examples:</p>
<pre><code>UPDATE t3 SET (t3_salary) = (t3_salary + 9) WHERE t3_name = 'aaa1'
</code></pre>
<pre><code>UPDATE t3 SET (t3_date, t3_country) = ('2017-11-18', 'india') WHERE t3_salary &lt; 15003
</code></pre>
<pre><code>UPDATE t3 SET (t3_country, t3_name) = (SELECT t5_country, t5_name FROM t5 WHERE t5_id = 5) WHERE t3_id &lt; 5
</code></pre>
<pre><code>UPDATE t3 SET (t3_date, t3_serialname, t3_salary) = (SELECT '2099-09-09', t5_serialname, '9999' FROM t5 WHERE t5_id = 5) WHERE t3_id &lt; 5
</code></pre>
<pre><code>UPDATE t3 SET (t3_country, t3_salary) = (SELECT t5_country, t5_salary FROM t5 FULL JOIN t3 u WHERE u.t3_id = t5_id and t5_id=6) WHERE t3_id &gt;6
</code></pre>
<p>NOTE: Update Complex datatype columns is not supported.</p>
<h3>
<a id="delete" class="anchor" href="#delete" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DELETE</h3>
<p>This command allows us to delete records from CarbonData table.</p>
<pre><code>DELETE FROM table_name [WHERE expression]
</code></pre>
<p>Examples:</p>
<pre><code>DELETE FROM carbontable WHERE column1  = 'china'
</code></pre>
<pre><code>DELETE FROM carbontable WHERE column1 IN ('china', 'USA')
</code></pre>
<pre><code>DELETE FROM carbontable WHERE column1 IN (SELECT column11 FROM sourceTable2)
</code></pre>
<pre><code>DELETE FROM carbontable WHERE column1 IN (SELECT column11 FROM sourceTable2 WHERE column1 = 'USA')
</code></pre>
<h2>
<a id="compaction" class="anchor" href="#compaction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>COMPACTION</h2>
<p>Compaction improves the query performance significantly.</p>
<p>There are several types of compaction.</p>
<pre><code>ALTER TABLE [db_name.]table_name COMPACT 'MINOR/MAJOR/CUSTOM'
</code></pre>
<ul>
<li><strong>Minor Compaction</strong></li>
</ul>
<p>In Minor compaction, user can specify the number of loads to be merged.
Minor compaction triggers for every data load if the parameter carbon.enable.auto.load.merge is set to true.
If any segments are available to be merged, then compaction will run parallel with data load, there are 2 levels in minor compaction:</p>
<ul>
<li>Level 1: Merging of the segments which are not yet compacted.</li>
<li>Level 2: Merging of the compacted segments again to form a larger segment.</li>
</ul>
<pre><code>ALTER TABLE table_name COMPACT 'MINOR'
</code></pre>
<ul>
<li><strong>Major Compaction</strong></li>
</ul>
<p>In Major compaction, multiple segments can be merged into one large segment.
User will specify the compaction size until which segments can be merged, Major compaction is usually done during the off-peak time.
Configure the property carbon.major.compaction.size with appropriate value in MB.</p>
<p>This command merges the specified number of segments into one segment:</p>
<pre><code>ALTER TABLE table_name COMPACT 'MAJOR'
</code></pre>
<ul>
<li><strong>Custom Compaction</strong></li>
</ul>
<p>In Custom compaction, user can directly specify segment ids to be merged into one large segment.
All specified segment ids should exist and be valid, otherwise compaction will fail.
Custom compaction is usually done during the off-peak time.</p>
<pre><code>ALTER TABLE table_name COMPACT 'CUSTOM' WHERE SEGMENT.ID IN (2,3,4)
</code></pre>
<p>NOTE: Compaction is unsupported for table containing Complex columns.</p>
<ul>
<li><strong>CLEAN SEGMENTS AFTER Compaction</strong></li>
</ul>
<p>Clean the segments which are compacted:</p>
<pre><code>CLEAN FILES FOR TABLE carbon_table
</code></pre>
<h2>
<a id="partition" class="anchor" href="#partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PARTITION</h2>
<h3>
<a id="standard-partition" class="anchor" href="#standard-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>STANDARD PARTITION</h3>
<p>The partition is similar as spark and hive partition, user can use any column to build partition:</p>
<h4>
<a id="create-partition-table" class="anchor" href="#create-partition-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create Partition Table</h4>
<p>This command allows you to create table with partition.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name 
  [(col_name data_type , ...)]
  [COMMENT table_comment]
  [PARTITIONED BY (col_name data_type , ...)]
  [STORED BY file_format]
  [TBLPROPERTIES (property_name=property_value, ...)]
</code></pre>
<p>Example:</p>
<pre><code> CREATE TABLE IF NOT EXISTS productSchema.productSalesTable (
                              productNumber INT,
                              productName STRING,
                              storeCity STRING,
                              storeProvince STRING,
                              saleQuantity INT,
                              revenue INT)
PARTITIONED BY (productCategory STRING, productBatch STRING)
STORED BY 'carbondata'
</code></pre>
<p>NOTE: Hive partition is not supported on complex datatype columns.</p>
<h4>
<a id="load-data-using-static-partition" class="anchor" href="#load-data-using-static-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load Data Using Static Partition</h4>
<p>This command allows you to load data using static partition.</p>
<pre><code>LOAD DATA [LOCAL] INPATH 'folder_path' 
INTO TABLE [db_name.]table_name PARTITION (partition_spec) 
OPTIONS(property_name=property_value, ...)    
INSERT INTO INTO TABLE [db_name.]table_name PARTITION (partition_spec) &lt;SELECT STATEMENT&gt;
</code></pre>
<p>Example:</p>
<pre><code>LOAD DATA LOCAL INPATH '${env:HOME}/staticinput.csv'
INTO TABLE locationTable
PARTITION (country = 'US', state = 'CA')  
INSERT INTO TABLE locationTable
PARTITION (country = 'US', state = 'AL')
SELECT &lt;columns list excluding partition columns&gt; FROM another_user
</code></pre>
<h4>
<a id="load-data-using-dynamic-partition" class="anchor" href="#load-data-using-dynamic-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load Data Using Dynamic Partition</h4>
<p>This command allows you to load data using dynamic partition. If partition spec is not specified, then the partition is considered as dynamic.</p>
<p>Example:</p>
<pre><code>LOAD DATA LOCAL INPATH '${env:HOME}/staticinput.csv'
INTO TABLE locationTable          
INSERT INTO TABLE locationTable
SELECT &lt;columns list excluding partition columns&gt; FROM another_user
</code></pre>
<h4>
<a id="show-partitions" class="anchor" href="#show-partitions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Show Partitions</h4>
<p>This command gets the Hive partition information of the table</p>
<pre><code>SHOW PARTITIONS [db_name.]table_name
</code></pre>
<h4>
<a id="drop-partition" class="anchor" href="#drop-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Drop Partition</h4>
<p>This command drops the specified Hive partition only.</p>
<pre><code>ALTER TABLE table_name DROP [IF EXISTS] PARTITION (part_spec, ...)
</code></pre>
<p>Example:</p>
<pre><code>ALTER TABLE locationTable DROP PARTITION (country = 'US');
</code></pre>
<h4>
<a id="insert-overwrite" class="anchor" href="#insert-overwrite" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Insert OVERWRITE</h4>
<p>This command allows you to insert or load overwrite on a specific partition.</p>
<pre><code> INSERT OVERWRITE TABLE table_name
 PARTITION (column = 'partition_name')
 select_statement
</code></pre>
<p>Example:</p>
<pre><code>INSERT OVERWRITE TABLE partitioned_user
PARTITION (country = 'US')
SELECT * FROM another_user au 
WHERE au.country = 'US';
</code></pre>
<h3>
<a id="carbondata-partitionhashrangelist----alpha-feature-this-partition-feature-does-not-support-update-and-delete-data" class="anchor" href="#carbondata-partitionhashrangelist----alpha-feature-this-partition-feature-does-not-support-update-and-delete-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CARBONDATA PARTITION(HASH,RANGE,LIST) -- Alpha feature, this partition feature does not support update and delete data.</h3>
<p>The partition supports three type:(Hash,Range,List), similar to other system's partition features, CarbonData's partition feature can be used to improve query performance by filtering on the partition column.</p>
<h3>
<a id="create-hash-partition-table" class="anchor" href="#create-hash-partition-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create Hash Partition Table</h3>
<p>This command allows us to create hash partition.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name
                  [(col_name data_type , ...)]
PARTITIONED BY (partition_col_name data_type)
STORED BY 'carbondata'
[TBLPROPERTIES ('PARTITION_TYPE'='HASH',
                'NUM_PARTITIONS'='N' ...)]
</code></pre>
<p><strong>NOTE:</strong> N is the number of hash partitions</p>
<p>Example:</p>
<pre><code>CREATE TABLE IF NOT EXISTS hash_partition_table(
    col_A STRING,
    col_B INT,
    col_C LONG,
    col_D DECIMAL(10,2),
    col_F TIMESTAMP
) PARTITIONED BY (col_E LONG)
STORED BY 'carbondata' TBLPROPERTIES('PARTITION_TYPE'='HASH','NUM_PARTITIONS'='9')
</code></pre>
<h3>
<a id="create-range-partition-table" class="anchor" href="#create-range-partition-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create Range Partition Table</h3>
<p>This command allows us to create range partition.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name
                  [(col_name data_type , ...)]
PARTITIONED BY (partition_col_name data_type)
STORED BY 'carbondata'
[TBLPROPERTIES ('PARTITION_TYPE'='RANGE',
                'RANGE_INFO'='2014-01-01, 2015-01-01, 2016-01-01, ...')]
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>The 'RANGE_INFO' must be defined in ascending order in the table properties.</li>
<li>The default format for partition column of Date/Timestamp type is yyyy-MM-dd. Alternate formats for Date/Timestamp could be defined in CarbonProperties.</li>
</ul>
<p>Example:</p>
<pre><code>CREATE TABLE IF NOT EXISTS range_partition_table(
    col_A STRING,
    col_B INT,
    col_C LONG,
    col_D DECIMAL(10,2),
    col_E LONG
 ) partitioned by (col_F Timestamp)
 PARTITIONED BY 'carbondata'
 TBLPROPERTIES('PARTITION_TYPE'='RANGE',
 'RANGE_INFO'='2015-01-01, 2016-01-01, 2017-01-01, 2017-02-01')
</code></pre>
<h3>
<a id="create-list-partition-table" class="anchor" href="#create-list-partition-table" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create List Partition Table</h3>
<p>This command allows us to create list partition.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name
                  [(col_name data_type , ...)]
PARTITIONED BY (partition_col_name data_type)
STORED BY 'carbondata'
[TBLPROPERTIES ('PARTITION_TYPE'='LIST',
                'LIST_INFO'='A, B, C, ...')]
</code></pre>
<p><strong>NOTE:</strong> List partition supports list info in one level group.</p>
<p>Example:</p>
<pre><code>CREATE TABLE IF NOT EXISTS list_partition_table(
    col_B INT,
    col_C LONG,
    col_D DECIMAL(10,2),
    col_E LONG,
    col_F TIMESTAMP
 ) PARTITIONED BY (col_A STRING)
 STORED BY 'carbondata'
 TBLPROPERTIES('PARTITION_TYPE'='LIST',
 'LIST_INFO'='aaaa, bbbb, (cccc, dddd), eeee')
</code></pre>
<h3>
<a id="show-partitions-1" class="anchor" href="#show-partitions-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Show Partitions</h3>
<p>The following command is executed to get the partition information of the table</p>
<pre><code>SHOW PARTITIONS [db_name.]table_name
</code></pre>
<h3>
<a id="add-a-new-partition" class="anchor" href="#add-a-new-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Add a new partition</h3>
<pre><code>ALTER TABLE [db_name].table_name ADD PARTITION('new_partition')
</code></pre>
<h3>
<a id="split-a-partition" class="anchor" href="#split-a-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Split a partition</h3>
<pre><code>ALTER TABLE [db_name].table_name SPLIT PARTITION(partition_id) INTO('new_partition1', 'new_partition2'...)
</code></pre>
<h3>
<a id="drop-a-partition" class="anchor" href="#drop-a-partition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Drop a partition</h3>
<p>Only drop partition definition, but keep data</p>
<pre><code>  ALTER TABLE [db_name].table_name DROP PARTITION(partition_id)
</code></pre>
<p>Drop both partition definition and data</p>
<pre><code>ALTER TABLE [db_name].table_name DROP PARTITION(partition_id) WITH DATA
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>Hash partition table is not supported for ADD, SPLIT and DROP commands.</li>
<li>Partition Id: in CarbonData like the hive, folders are not used to divide partitions instead partition id is used to replace the task id. It could make use of the characteristic and meanwhile reduce some metadata.</li>
</ul>
<pre><code>SegmentDir/0_batchno0-0-1502703086921.carbonindex
          ^
SegmentDir/part-0-0_batchno0-0-1502703086921.carbondata
                   ^
</code></pre>
<p>Here are some useful tips to improve query performance of carbonData partition table:</p>
<ul>
<li>The partitioned column can be excluded from SORT_COLUMNS, this will let other columns to do the efficient sorting.</li>
<li>When writing SQL on a partition table, try to use filters on the partition column.</li>
</ul>
<h2>
<a id="bucketing" class="anchor" href="#bucketing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BUCKETING</h2>
<p>Bucketing feature can be used to distribute/organize the table/partition data into multiple files such
that similar records are present in the same file. While creating a table, user needs to specify the
columns to be used for bucketing and the number of buckets. For the selection of bucket the Hash value
of columns is used.</p>
<pre><code>CREATE TABLE [IF NOT EXISTS] [db_name.]table_name
                  [(col_name data_type, ...)]
STORED BY 'carbondata'
TBLPROPERTIES('BUCKETNUMBER'='noOfBuckets',
'BUCKETCOLUMNS'='columnname')
</code></pre>
<p><strong>NOTE:</strong></p>
<ul>
<li>Bucketing cannot be performed for columns of Complex Data Types.</li>
<li>Columns in the BUCKETCOLUMN parameter must be dimensions. The BUCKETCOLUMN parameter cannot be a measure or a combination of measures and dimensions.</li>
</ul>
<p>Example:</p>
<pre><code>CREATE TABLE IF NOT EXISTS productSchema.productSalesTable (
                              productNumber INT,
                              saleQuantity INT,
                              productName STRING,
                              storeCity STRING,
                              storeProvince STRING,
                              productCategory STRING,
                              productBatch STRING,
                              revenue INT)
STORED BY 'carbondata'
TBLPROPERTIES ('BUCKETNUMBER'='4', 'BUCKETCOLUMNS'='productName')
</code></pre>
<h2>
<a id="segment-management" class="anchor" href="#segment-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SEGMENT MANAGEMENT</h2>
<h3>
<a id="show-segment" class="anchor" href="#show-segment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SHOW SEGMENT</h3>
<p>This command is used to list the segments of CarbonData table.</p>
<pre><code>SHOW [HISTORY] SEGMENTS FOR TABLE [db_name.]table_name LIMIT number_of_segments
</code></pre>
<p>Example:
Show visible segments</p>
<pre><code>SHOW SEGMENTS FOR TABLE CarbonDatabase.CarbonTable LIMIT 4
</code></pre>
<p>Show all segments, include invisible segments</p>
<pre><code>SHOW HISTORY SEGMENTS FOR TABLE CarbonDatabase.CarbonTable LIMIT 4
</code></pre>
<h3>
<a id="delete-segment-by-id" class="anchor" href="#delete-segment-by-id" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DELETE SEGMENT BY ID</h3>
<p>This command is used to delete segment by using the segment ID. Each segment has a unique segment ID associated with it.
Using this segment ID, you can remove the segment.</p>
<p>The following command will get the segmentID.</p>
<pre><code>SHOW SEGMENTS FOR TABLE [db_name.]table_name LIMIT number_of_segments
</code></pre>
<p>After you retrieve the segment ID of the segment that you want to delete, execute the following command to delete the selected segment.</p>
<pre><code>DELETE FROM TABLE [db_name.]table_name WHERE SEGMENT.ID IN (segment_id1, segments_id2, ...)
</code></pre>
<p>Example:</p>
<pre><code>DELETE FROM TABLE CarbonDatabase.CarbonTable WHERE SEGMENT.ID IN (0)
DELETE FROM TABLE CarbonDatabase.CarbonTable WHERE SEGMENT.ID IN (0,5,8)
</code></pre>
<h3>
<a id="delete-segment-by-date" class="anchor" href="#delete-segment-by-date" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DELETE SEGMENT BY DATE</h3>
<p>This command will allow to delete the CarbonData segment(s) from the store based on the date provided by the user in the DML command.
The segment created before the particular date will be removed from the specific stores.</p>
<pre><code>DELETE FROM TABLE [db_name.]table_name WHERE SEGMENT.STARTTIME BEFORE DATE_VALUE
</code></pre>
<p>Example:</p>
<pre><code>DELETE FROM TABLE CarbonDatabase.CarbonTable WHERE SEGMENT.STARTTIME BEFORE '2017-06-01 12:05:06' 
</code></pre>
<h3>
<a id="query-data-with-specified-segments" class="anchor" href="#query-data-with-specified-segments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>QUERY DATA WITH SPECIFIED SEGMENTS</h3>
<p>This command is used to read data from specified segments during CarbonScan.</p>
<p>Get the Segment ID:</p>
<pre><code>SHOW SEGMENTS FOR TABLE [db_name.]table_name LIMIT number_of_segments
</code></pre>
<p>Set the segment IDs for table</p>
<pre><code>SET carbon.input.segments.&lt;database_name&gt;.&lt;table_name&gt; = &lt;list of segment IDs&gt;
</code></pre>
<p><strong>NOTE:</strong>
carbon.input.segments: Specifies the segment IDs to be queried. This property allows you to query specified segments of the specified table. The CarbonScan will read data from specified segments only.</p>
<p>If user wants to query with segments reading in multi threading mode, then CarbonSession. threadSet can be used instead of SET query.</p>
<pre><code>CarbonSession.threadSet ("carbon.input.segments.&lt;database_name&gt;.&lt;table_name&gt;","&lt;list of segment IDs&gt;");
</code></pre>
<p>Reset the segment IDs</p>
<pre><code>SET carbon.input.segments.&lt;database_name&gt;.&lt;table_name&gt; = *;
</code></pre>
<p>If user wants to query with segments reading in multi threading mode, then CarbonSession. threadSet can be used instead of SET query.</p>
<pre><code>CarbonSession.threadSet ("carbon.input.segments.&lt;database_name&gt;.&lt;table_name&gt;","*");
</code></pre>
<p><strong>Examples:</strong></p>
<ul>
<li>Example to show the list of segment IDs,segment status, and other required details and then specify the list of segments to be read.</li>
</ul>
<pre><code>SHOW SEGMENTS FOR carbontable1;

SET carbon.input.segments.db.carbontable1 = 1,3,9;
</code></pre>
<ul>
<li>Example to query with segments reading in multi threading mode:</li>
</ul>
<pre><code>CarbonSession.threadSet ("carbon.input.segments.db.carbontable_Multi_Thread","1,3");
</code></pre>
<ul>
<li>Example for threadset in multithread environment (following shows how it is used in Scala code):</li>
</ul>
<pre><code>def main(args: Array[String]) {
Future {          
  CarbonSession.threadSet ("carbon.input.segments.db.carbontable_Multi_Thread","1")
  spark.sql("select count(empno) from carbon.input.segments.db.carbontable_Multi_Thread").show();
   }
 }
</code></pre>
</div>
</div>
</div>
</div>
<div class="doc-footer">
    <a href="#top" class="scroll-top">Top</a>
</div>
</div>
</section>
</div>
</div>
</div>
</section><!-- End systemblock part -->
<script src="js/custom.js"></script>
</body>
</html>